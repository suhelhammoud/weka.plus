Index: src/weka/attributeSelection/Pas2AttributeEval.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package weka.attributeSelection;\n\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport weka.attributeSelection.pas2.*;\nimport weka.attributeSelection.pas2.PasOptions2;\nimport weka.core.*;\nimport weka.filters.Filter;\nimport weka.filters.supervised.attribute.Discretize;\nimport weka.filters.unsupervised.attribute.NumericToBinary;\n\nimport java.util.*;\n\n\n/**\n * <!-- globalinfo-start --> Practical Attribute Selection :<br/>\n * <br/>\n * Evaluates the worth of an attribute by measuring the practical initial coverage.<br/>\n * capability of it\n * <br/>\n * <p/>\n * <!-- globalinfo-end -->\n * <p>\n * <!-- options-start --> Valid options are:\n * <p/>\n * <p>\n * <pre>\n * -M\n *  treat missing values as a seperate value.\n * </pre>\n * <p>\n * <pre>\n * -B\n *  just binarize numeric attributes instead\n *  of properly discretizing them.\n * </pre>\n * <p>\n * <!-- technical-bibtex-start --> BibTeX:\n *\n * <pre>\n * &#64;inproceedings{todo,\n *    address = {todo},\n *    author = {Suhel, Fadi},\n *    journal title = { todo},\n *    pages = {xxx-xxx},\n *    publisher = {todo},\n *    title = {TODO},\n *    year = {2018}\n * }\n * </pre>\n * <p/>\n * <!-- technical-bibtex-end -->\n * <!-- options-end -->\n *\n * @author Fadi  (f.thabtah@gmail.com)\n * @author Suhel (suhel.hammoud@gmail.com)\n * @version $Revision: 00007778 $\n * @see Discretize\n * @see NumericToBinary\n */\n\n\npublic class Pas2AttributeEval extends ASEvaluation implements\n        AttributeEvaluator, OptionHandler {\n\n  static Logger logger = LoggerFactory.getLogger(Pas2AttributeEval.class.getName());\n\n  PasOptions2 pasOptions = new PasOptions2();\n\n\n\n  /**\n   * for serialization\n   */\n  static final long serialVersionUID = -3049819495125894189L;\n\n  /**\n   * The Pas ranking value for each attribute\n   */\n  private double[] m_pas;\n\n  public double getCutOffThreshold() {\n    return pasOptions.getCutOffThreshold();\n  }\n\n  public void setCutOffThreshold(double cutOffThreshold) {\n    pasOptions.setCutOffThreshold(cutOffThreshold);\n  }\n\n  public double[] getAttributesRanks() {\n    return Arrays.copyOf(m_pas, m_pas.length);\n  }\n\n  /**\n   * evaluates an individual attribute by measuring Its Va values\n   *\n   * @param attribute the index of the attribute to be evaluated\n   * @return the Va value\n   * @throws Exception if the attribute could not be evaluated\n   */\n  @Override\n  public double evaluateAttribute(int attribute) throws Exception {\n    return m_pas[attribute];\n  }\n\n  /**\n   * Returns a string describing this attribute evaluator\n   *\n   * @return a description of the evaluator suitable for displaying in the\n   * explorer/experimenter gui\n   */\n  public String globalInfo() {\n    return \"Pas AttributeEval :\\n\\nEvaluates the worth of an attribute \"\n            + \"\\n more info on :\\nhttps://gitlab.com/suhel.hammoud/weka.plus/tree/master/src/weka/attributeSelection/PasAttributeEval.java\";\n  }\n\n  /**\n   * Constructor\n   */\n  public Pas2AttributeEval() {\n    resetOptions();\n  }\n\n  /**\n   * Returns an enumeration describing the available options.\n   *\n   * @return an enumeration of all the available options.\n   **/\n  @Override\n  public Enumeration<Option> listOptions() {\n    return pasOptions.listOptions();\n  }\n\n\n  @Override\n  public void setOptions(String[] options) throws Exception {\n    pasOptions.setOptions(options);\n  }\n\n  /**\n   * @return an array of strings suitable for passing to setOptions()\n   */\n  @Override\n  public String[] getOptions() {\n    return pasOptions.getOptions();\n  }\n\n\n  /**\n   * Returns the capabilities of this evaluator.\n   *\n   * @return the capabilities of this evaluator\n   * @see Capabilities\n   */\n  @Override\n  public Capabilities getCapabilities() {\n    Capabilities result = super.getCapabilities();\n    result.disableAll();\n\n    // attributes\n    result.enable(Capabilities.Capability.NOMINAL_ATTRIBUTES);\n    result.enable(Capabilities.Capability.NUMERIC_ATTRIBUTES);\n    result.enable(Capabilities.Capability.MISSING_VALUES); // TODO check if applicable\n\n    // class\n    result.enable(Capabilities.Capability.NOMINAL_CLASS);\n    result.enable(Capabilities.Capability.MISSING_CLASS_VALUES); //TODO check if applicable\n\n    return result;\n  }\n\n  /**\n   * PAS attribute evaluator\n   *\n   * @param initialData set of instances serving as training dataset\n   * @throws Exception if the evaluator has not been generated successfully\n   */\n  @Override\n  public void buildEvaluator(Instances initialData) throws Exception {\n    // can evaluator handle dataset?\n    getCapabilities().testWithFail(initialData);\n\n    Instances data = null;\n\n    if (!pasOptions.getBinarizeNumericAttributes()) {\n      Discretize disTransform = new Discretize();\n      disTransform.setUseBetterEncoding(true);\n      disTransform.setInputFormat(initialData);\n      data = Filter.useFilter(initialData, disTransform);\n    } else {\n      NumericToBinary binTransform = new NumericToBinary();\n      binTransform.setInputFormat(initialData);\n      data = Filter.useFilter(initialData, binTransform);\n    }\n\n    data.setRelationName(initialData.relationName());\n\n    //TODO look into Chi implementation of contingency tables\n    logger.debug(\"build classifier with data ={} of size={}\", data.relationName(), data.numInstances());\n\n    assert data.classIndex() == data.numAttributes() - 1;\n\n    data.setClassIndex(data.numAttributes() - 1);\n    logger.debug(\"build pas evaluator\");\n\n    Tuple2<Collection<int[]>, int[]> linesLabels = PasUtils2.mapIdataAndLabels(data);\n    Collection<int[]> lineData = linesLabels.k;\n    int[] labelsCount = linesLabels.v;\n//\n    logger.trace(\"original lines size ={}\", lineData.size());\n\n    int[] numItems = PasUtils2.countItemsInAttributes(data);\n\n    int minFreq = (int) Math.ceil(pasOptions.getsetMinItemStrength()\n            * data.numInstances() + 1.e-6);\n    logger.debug(\"minFreq used = {}\", minFreq);\n\n    List<PasItem2> items = new ArrayList<>();\n\n    final PasMethod2 pasMethod2 = pasOptions.getPasMethodEnum();\n\n    switch (pasMethod2) {\n      case rules:\n        items = PasUtils2.evaluateAttributesRules(numItems,\n                labelsCount,\n                lineData,\n                minFreq,\n                1 - pasOptions.getMinRuleError(),\n                false);\n//                logger.info(\"run att eval with algorithm rules = {}\", items.size());\n\n        break;\n      case rules1st:\n\n        items = PasUtils2.evaluateAttributesRules1st(numItems,\n                labelsCount,\n                lineData,\n                minFreq,\n                1 - pasOptions.getMinRuleError(),\n                false);\n\n//                logger.info(\"run att eval with algorithm rules1st = {}\", items.size());\n\n        break;\n      case items:\n        items = PasUtils2.evaluateAttributesItems(numItems,\n                labelsCount,\n                lineData,\n                minFreq,\n                1 - pasOptions.getMinRuleError(),\n                false);\n//                logger.info(\"run att eval with algorithm items = {}\", items.size());\n        break;\n    }\n\n\n    double[] rawRanks = PasUtils2.rankAttributes(\n            items,\n            data.numAttributes() - 1,\n            pasMethod2\n    );//exclude label class attribute\n\n\n    m_pas = PasUtils2.normalizeVector(rawRanks);\n\n    if (pasOptions.getShowDebugMessages()) {\n      String msg = PasUtils2.printResult(items,\n              data,\n              Arrays.stream(rawRanks).sum(),\n              data.numAttributes() - 1);\n      logger.info(msg);\n    }\n  }\n\n\n  /**\n   * Reset options to their default values\n   */\n  protected void resetOptions() {\n    pasOptions.resetOptions();\n  }\n\n\n  /**\n   * Describe the attribute evaluator\n   *\n   * @return a description of the attribute evaluator as a string\n   */\n  @Override\n  public String toString() {\n    StringBuilder text = new StringBuilder();\n    if (m_pas == null) {  //Va\n      text.append(\"Pas attribute evaluator has not been built\");\n    } else { //All OK\n      text.append(\"\\tPas Ranking Filter\");\n\n\n      if (!getMissingMerge()) {\n        text.append(\"\\n\\tMissing values treated as separate\"); //TODO check\n      }\n      if (getBinarizeNumericAttributes()) {\n        text.append(\"\\n\\tNumeric attributes are just binarized\");\n      }\n    }\n\n    text.append(\"\\n\\t Minimum Item Strength: \" + getMinItemStrength());\n    text.append(\"\\n\\t Minimum Rule Error: \" + getMinRuleError());\n\n    text.append(\"\\n\");\n    text.append(\"\\n\");\n    text.append(PasUtils2.printRanks(m_pas));\n    text.append(\"\\n\\n\");\n    text.append(PasUtils2.printCutOffPoint(m_pas, pasOptions.getCutOffThreshold()));\n\n\n    text.append(\"\\n\");\n\n    return text.toString();\n  }\n\n  public SelectedTag getPasMethod() {\n    return pasOptions.getPashMethod();\n  }\n\n  public void setPasMethod(SelectedTag tag) {\n    pasOptions.setPasMethod(tag);\n  }\n\n  public void setPasMethod(PasMethod2 pm) {\n    pasOptions.setPasMethod(pm);\n  }\n\n  public double getMinItemStrength() {\n    return pasOptions.getsetMinItemStrength();\n  }\n\n  public void setMinItemStrength(double minItemStrength) {\n    pasOptions.setMinItemStrength(minItemStrength);\n  }\n\n  public String minItemStrengthTipText() {\n    return \"Min item strength tip text\";\n  }\n\n  public double getMinRuleError() {\n    return pasOptions.getMinRuleError();\n  }\n\n  public void setMinRuleError(double minRuleError) {\n    pasOptions.setMinRuleError(minRuleError);\n  }\n\n  public String minRuleErrorTipText() {\n    return \"Min rule error tip text\";\n  }\n\n\n  public void setMissingMerge(boolean b) {\n    pasOptions.setMissingMerge(b);\n  }\n\n  public boolean getMissingMerge() {\n    return pasOptions.getMissingMerge();\n  }\n\n  public void setBinarizeNumericAttributes(boolean b) {\n    pasOptions.setBinarizeNumericAttributes(b);\n  }\n\n  public boolean getBinarizeNumericAttributes() {\n    return pasOptions.getBinarizeNumericAttributes();\n  }\n\n  public boolean getShowDebugMessages() {\n    return pasOptions.getShowDebugMessages();\n  }\n\n  public void setShowDebugMessages(boolean b) {\n    pasOptions.setShowDebugMessages(b);\n  }\n\n  public boolean getShowCutOffPoint() {\n    return pasOptions.getShowCuttOffPoint();\n  }\n\n  public void setShowCutOffPoint(boolean b) {\n    pasOptions.setShowCutOffPoint(b);\n  }\n\n\n\n  /**\n   * Returns the revision string.\n   *\n   * @return the revision\n   */\n  @Override\n  public String getRevision() {\n    return RevisionUtils.extract(\"$Revision: 00007778 $\"); //arbitrary number\n  }\n\n  // ============\n  // Test method.\n  // ============\n\n  /**\n   * Main method for testing this class.\n   *\n   * @param args the options\n   */\n  public static void main(String[] args) {\n    runEvaluator(new Pas2AttributeEval(), args);\n\n  }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/weka/attributeSelection/Pas2AttributeEval.java b/src/weka/attributeSelection/Pas2AttributeEval.java
--- a/src/weka/attributeSelection/Pas2AttributeEval.java	(revision 738757a4a6578a5b57eb5e2e9256b6f1ae6ba237)
+++ b/src/weka/attributeSelection/Pas2AttributeEval.java	(date 1617373780062)
@@ -69,7 +69,6 @@
   PasOptions2 pasOptions = new PasOptions2();
 
 
-
   /**
    * for serialization
    */
@@ -212,9 +211,9 @@
 
     int[] numItems = PasUtils2.countItemsInAttributes(data);
 
-    int minFreq = (int) Math.ceil(pasOptions.getsetMinItemStrength()
+    int minItemStrength = (int) Math.ceil(pasOptions.getsetMinItemStrength()
             * data.numInstances() + 1.e-6);
-    logger.debug("minFreq used = {}", minFreq);
+    logger.debug("minFreq used = {}", minItemStrength);
 
     List<PasItem2> items = new ArrayList<>();
 
@@ -225,7 +224,7 @@
         items = PasUtils2.evaluateAttributesRules(numItems,
                 labelsCount,
                 lineData,
-                minFreq,
+                minItemStrength,
                 1 - pasOptions.getMinRuleError(),
                 false);
 //                logger.info("run att eval with algorithm rules = {}", items.size());
@@ -236,7 +235,7 @@
         items = PasUtils2.evaluateAttributesRules1st(numItems,
                 labelsCount,
                 lineData,
-                minFreq,
+                minItemStrength,
                 1 - pasOptions.getMinRuleError(),
                 false);
 
@@ -247,7 +246,7 @@
         items = PasUtils2.evaluateAttributesItems(numItems,
                 labelsCount,
                 lineData,
-                minFreq,
+                minItemStrength,
                 1 - pasOptions.getMinRuleError(),
                 false);
 //                logger.info("run att eval with algorithm items = {}", items.size());
@@ -389,7 +388,6 @@
   }
 
 
-
   /**
    * Returns the revision string.
    *
Index: src/weka/attributeSelection/pas2/PasUtils2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package weka.attributeSelection.pas2;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport weka.core.Instance;\nimport weka.core.Instances;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class PasUtils2 {\n\n  //TODO use IRule now with one condition test, create separate class later.\n\n  static Logger logger = LoggerFactory.getLogger(PasUtils2.class.getName());\n\n  public static List<Integer> buildEvaluator(Instances data,\n                                             double support,\n                                             double confidence) {\n\n    logger.debug(\"build pas evaluator\");\n\n    Tuple2<Collection<int[]>, int[]> linesLabels = PasUtils2.mapIdataAndLabels(data);\n    Collection<int[]> lineData = linesLabels.k;\n    int[] labelsCount = linesLabels.v;\n//\n    logger\n            .trace(\"original lines size ={}\", lineData.size());\n\n    int[] numItems = PasUtils2.countItemsInAttributes(data);\n\n\n    return null;\n  }\n\n  public static String arrayToString(double[] arr, String format) {\n    return Arrays.stream(arr)\n            .boxed()\n            .map(d -> String.format(format, d))\n            .collect(Collectors.joining(\", \", \"[\", \"]\"));\n  }\n\n  public static double[] rankAttributes(List<PasItem2> items,\n                                        int numAttributes,\n                                        PasMethod2 pasMethod2) {\n\n    int totalLines = items.stream()\n            .mapToInt(rule -> rule.getCovers())\n            .sum();\n\n    double[] result = new double[numAttributes];\n\n    for (PasItem2 item : items) {\n      final double weight = item.getCorrect() * totalLines;\n      final double weightFirst = item.getFirstCorrect() * totalLines;\n\n      totalLines -= item.getCovers();\n\n      switch (pasMethod2) {\n        case rules:\n          for (int aIndex : item.getAttIndexes()) {\n            result[aIndex] += weight;\n          }\n          break;\n\n        case rules1st:\n          result[item.getAttIndexes()[0]] += weightFirst;\n          break;\n\n        case items:\n          result[item.getAttIndexes()[0]] += weight;\n      }\n    }\n    return result;\n\n  }\n\n\n  public static List<PasItem2> evaluateAttributesItems(int[] numItems,\n                                                       int[] labelsCount,\n                                                       Collection<int[]> lineData,\n                                                       int minFreq,\n                                                       double minConfidence,\n                                                       boolean addDefaultItem) {\n    List<PasItem2> items = new ArrayList<>();\n\n    int labelIndex = numItems.length - 1;\n    int numLabels = numItems[labelIndex];\n    assert numItems[labelIndex] == labelsCount.length;\n\n    int lineDataSize = lineData.size();\n\n    Collection<int[]> remainingLines = null;\n\n\n    Collection<int[]> lines = lineData;//new ArrayList<>(lineData);//defensive copy\n\n\n    while (lineDataSize > 0) {\n\n      Tuple2<PasItem2, Collection<int[]>> itmlns = calcStepItem(numItems, lines, minFreq, minConfidence);\n      if (itmlns == null) break; // stop adding rules for current class. break out to the new class\n\n      logger.trace(\"rule {}\", itmlns.k);\n      logger.trace(\"remaining lines={}\", itmlns.v.size());\n\n      lines = itmlns.v;\n      remainingLines = lines;\n      lineDataSize -= itmlns.k.getCorrect();\n      logger.trace(\"took {} , remains {} instances\",\n              itmlns.k.getCorrect(), lineDataSize);\n\n      items.add(itmlns.k);\n    }\n\n    if (addDefaultItem) {\n      if (remainingLines != null && remainingLines.size() > 0) {\n        PasItem2 item = getDefaultPasItem(remainingLines, labelIndex, numLabels);\n        items.add(item);\n      }\n    }\n\n    //TODO check to add defaultRule\n    assert items.size() > 0;\n    return items;\n  }\n\n\n  public static List<PasItem2> evaluateAttributesRules(int[] numItems,\n                                                       int[] labelsCount,\n                                                       Collection<int[]> lineData,\n                                                       int minFreq,\n                                                       double minConfidence,\n                                                       boolean addDefaultRule) {\n    List<PasItem2> result = new ArrayList<>();\n\n    int labelIndex = numItems.length - 1;\n    int numLabels = numItems[labelIndex];\n    assert numItems[labelIndex] == labelsCount.length;\n\n    int lineDataSize = lineData.size();\n\n    Collection<int[]> remainingLines = null;\n\n\n    Collection<int[]> lines = lineData;//new ArrayList<>(lineData);//defensive copy\n\n\n    while (lineDataSize > 0) {\n\n      Tuple2<PasItem2, Collection<int[]>> rllns = calcStepRule(numItems, lines, minFreq, minConfidence);\n      if (rllns == null) break; // stop adding rules for current class. break out to the new class\n\n\n      logger.trace(\"rule {}\", rllns.k);\n      logger.trace(\"remaining lines={}\", rllns.v.size());\n\n      lines = rllns.v;\n      remainingLines = lines;\n      lineDataSize -= rllns.k.getCorrect();\n      logger.trace(\"took {} , remains {} instances\",\n              rllns.k.getCorrect(), lineDataSize);\n\n      result.add(rllns.k);\n    }\n\n    if (addDefaultRule) {\n      if (remainingLines != null && remainingLines.size() > 0) {\n        PasItem2 rule = getDefaultPasItem(remainingLines, labelIndex, numLabels);\n        result.add(rule);\n      }\n    }\n\n    //TODO check to add defaultRule\n    assert result.size() > 0;\n    return result;\n  }\n\n\n  public static List<PasItem2> evaluateAttributesRules1st(int[] numItems,\n                                                          int[] labelsCount,\n                                                          Collection<int[]> lineData,\n                                                          int minFreq,\n                                                          double minConfidence,\n                                                          boolean addDefaultRule) {\n    List<PasItem2> result = new ArrayList<>();\n\n    int labelIndex = numItems.length - 1;\n    int numLabels = numItems[labelIndex];\n    assert numItems[labelIndex] == labelsCount.length;\n\n    int lineDataSize = lineData.size();\n\n    Collection<int[]> remainingLines = null;\n\n\n    Collection<int[]> lines = lineData;//new ArrayList<>(lineData);//defensive copy\n\n\n    while (lineDataSize > 0) {\n\n      Tuple2<PasItem2, Collection<int[]>> rllns = calcStepRule(numItems, lines, minFreq, minConfidence);\n      if (rllns == null) break; // stop adding rules for current class. break out to the new class\n\n\n      logger.trace(\"rule {}\", rllns.k);\n      logger.trace(\"remaining lines={}\", rllns.v.size());\n\n      lines = rllns.v;\n      remainingLines = lines;\n      lineDataSize -= rllns.k.getCorrect();\n      logger.trace(\"took {} , remains {} instances\",\n              rllns.k.getCorrect(), lineDataSize);\n\n      result.add(rllns.k);\n    }\n\n    if (addDefaultRule) {\n      if (remainingLines != null && remainingLines.size() > 0) {\n        PasItem2 rule = getDefaultPasItem(remainingLines, labelIndex, numLabels);\n        result.add(rule);\n      }\n    }\n\n    //TODO check to add defaultRule\n    assert result.size() > 0;\n\n    return result;\n  }\n\n\n  public static double[] normalizeVector(double[] values) {\n    double sum = Arrays.stream(values).sum();\n    return Arrays.stream(values)\n            .map(value -> value / sum)\n            .toArray();\n  }\n\n\n  public static Tuple2<PasItem2, Collection<int[]>> calcStepItem(int[] numItemsInAtt,\n                                                                 Collection<int[]> lineData,\n                                                                 int minFreq,\n                                                                 double minConfidence) {\n\n    if (lineData.size() < minFreq) return null;\n\n    /** Start with all attributes, does not include the label attribute*/\n    Set<Integer> availableAttributes = IntStream.range(0, numItemsInAtt.length - 1)\n            .boxed()\n            .collect(Collectors.toSet());\n\n    int[][][] stepCount = countStep(numItemsInAtt,\n            lineData,\n            intsToArray((availableAttributes)));\n\n    PasMax2 mx = PasMax2.ofThreshold(stepCount, minFreq, minConfidence);\n    if (mx.getLabel() == PasMax2.EMPTY)\n      return null; //TODO not reached, check carefully\n\n    //found best next item\n    assert mx.getLabel() != PasMax2.EMPTY;\n    assert mx.getBestAtt() >= 0;\n    assert mx.getBestItem() >= 0;\n\n    //rule with more attributes conditions\n    final PasItem2 item = new PasItem2(mx.getLabel(), mx.getBestCorrect(), mx.getBestCover());\n    item.addTest(mx.getBestAtt(), mx.getBestItem(), mx.getBestCorrect());\n\n    List<int[]> notCoveredLines = lineData.stream()\n            .filter(row -> !item.canCoverInstance(row))\n            .collect(Collectors.toList());\n    if (item.getLength() == 0) {//TODO more inspection is needed here\n      return null;\n    }\n\n    return Tuple2.of(item, notCoveredLines);\n  }\n\n\n  public static Tuple2<PasItem2, Collection<int[]>> calcStepRule(int[] numItemsInAtt,\n                                                                 Collection<int[]> lineData,\n                                                                 int minFreq,\n                                                                 double minConfidence) {\n\n    if (lineData.size() < minFreq) return null;\n\n//        int labelIndex = countItemsInAttributes.length - 1;\n//        int numLabels = countItemsInAttributes[labelIndex];\n\n    /** Start with all attributes, does not include the label attribute*/\n    Set<Integer> availableAttributes = IntStream.range(0, numItemsInAtt.length - 1)\n            .boxed()\n            .collect(Collectors.toSet());\n\n//        Set<Integer> avAtts = new LinkedHashSet<>();\n//        for (int i = 0; i < labelIndex; i++) avAtts.add(i);\n\n    PasItem2 rule = null;// null, Does not know the label yet\n    PasMax2 mx = null;\n\n    Collection<int[]> entryLines = lineData; // start with all lines\n    Collection<int[]> notCoveredLines = new ArrayList<>(lineData.size());//none covered\n    do {\n\n      int[][][] stepCount = countStep(numItemsInAtt,\n              entryLines,\n              intsToArray(availableAttributes));\n      if (mx == null) {\n        //For the first time\n        mx = PasMax2.ofThreshold(stepCount, minFreq, minConfidence);\n\n        if (mx.getLabel() == PasMax2.EMPTY) return null;\n        rule = new PasItem2(mx.getLabel());\n      } else {\n        mx = PasMax2.ofThreshold(stepCount,\n                minFreq,\n                minConfidence,\n                mx.getLabel());\n        if (mx.getLabel() == PasMax2.EMPTY) break;\n\n      }\n\n      //found best next item\n      assert mx.getLabel() != PasMax2.EMPTY;\n      assert mx.getLabel() == rule.label;\n      assert mx.getBestAtt() >= 0;\n      assert mx.getBestItem() >= 0;\n\n      availableAttributes.remove(mx.getBestAtt());\n\n      //refine rule with more attributes conditions\n      rule.addTest(mx.getBestAtt(), mx.getBestItem(), mx.getBestCorrect());\n      rule.updateWith(mx);\n\n      PasItem2 finalRule = rule;\n      Map<Boolean, List<int[]>> coveredLines = entryLines.stream()\n              .collect(Collectors.partitioningBy(row -> finalRule.canCoverInstance(row)));\n\n      notCoveredLines.addAll(coveredLines.get(false));\n\n      entryLines = coveredLines.get(true);\n\n    } while (rule.getErrors() > 0\n            && availableAttributes.size() > 0\n            && rule.getCorrect() >= minFreq);\n\n    if (rule.getLength() == 0) {//TODO more inspection is needed here\n      return null;\n    }\n\n    return Tuple2.of(rule, notCoveredLines);\n  }\n\n\n  /**\n   * Gets the majority class in the labels of the remaining instances, do not check attributes\n   *\n   * @param lines\n   * @param labelIndex\n   * @param numLabels\n   * @return\n   */\n  private static PasItem2 getDefaultPasItem(Collection<int[]> lines,\n                                            int labelIndex,\n                                            int numLabels) {\n    int[] freqs = new int[numLabels];\n    for (int[] line : lines) {\n      freqs[line[labelIndex]]++;\n    }\n    int maxVal = Integer.MIN_VALUE;\n    int maxIndex = Integer.MIN_VALUE;\n    for (int i = 0; i < freqs.length; i++) {\n      if (freqs[i] > maxVal) {\n        maxVal = freqs[i];\n        maxIndex = i;\n      }\n    }\n    return new PasItem2(maxIndex, maxVal, PasMax2.sum(freqs));\n  }\n\n  /**\n   * @param attValues\n   * @param lineData\n   * @param availableAttributes\n   * @return counter of frequencies of labels as an array [i][j][k] :\n   * i: attribute\n   * j: item in attribute i\n   * k: label class\n   * (att, item, label) -> count\n   */\n  public static int[][][] countStep(int[] attValues, Collection<int[]> lineData, int[] availableAttributes) {\n\n    int labelIndex = attValues.length - 1;\n    int numLabels = attValues[labelIndex];\n\n    //create array of One attributes, without the class name;\n    int[][][] result = new int[attValues.length][][];\n\n    for (int att : availableAttributes) {\n      result[att] = new int[attValues[att]][numLabels];\n    }\n    //fill remaining attributes with empty arrays\n    for (int i = 0; i < result.length; i++) {\n      if (result[i] == null) result[i] = new int[0][0];\n    }\n\n    //filling with values\n    for (int[] row : lineData) {\n      int cls = row[labelIndex];\n\n      for (int a : availableAttributes)\n        result[a][row[a]][cls]++;\n    }\n    return result;\n  }\n\n\n  public static int[] intsToArray(Set<Integer> set) {\n    return set.stream()\n            .mapToInt(Number::intValue)\n            .toArray();\n  }\n\n\n  //TODO delete later\n  public static String printResult(List<PasItem2> rules,\n                                   Instances data,\n                                   double sumWeights,\n                                   int numAttributes) {\n    StringBuilder result = new StringBuilder();\n\n    StringJoiner sj = new StringJoiner(\"\\n\\t\",\n            \"\\n\" + data.relationName() + \"\\n\\t\",\n            \"\\n\\n\");\n//        double sumWeights = Arrays.stream(rawRanks).sum();\n\n    final int totalLines = rules.stream()\n            .mapToInt(rule -> rule.getCovers())\n            .sum();\n    int availableLines = totalLines;\n\n    double[] rawRanks = new double[numAttributes];\n    for (PasItem2 rule : rules) {\n//            sj.add(\"rule: \" + rule.toString(data, 3));\n      sj.add(\"rule: \" + rule.toString());\n      final double linesRatio = (double) availableLines / totalLines;\n      final double weight = rule.getCorrect()\n              * availableLines;\n      sj.add(String.format(\"weight = %06.1f , lines = %04d, lines ratio = %3.3f\",\n              weight,\n              availableLines,\n              linesRatio));\n      availableLines -= rule.getCovers();\n      for (int attIndex : rule.getAttIndexes()) {\n        rawRanks[attIndex] += weight;\n      }\n    }\n\n    sj.add(\"Result attributes weights\");\n    sj.add(Arrays.toString(rawRanks));\n\n    sj.add(\"Normalized Attributes weights\");\n\n    sj.add(PasUtils2.arrayToString(PasUtils2.normalizeVector(rawRanks),\n            \"%1.3f\"));\n\n    return sj.toString();\n  }\n\n  public static String printRanks(double[] ranks) {\n    StringJoiner sj = new StringJoiner(\"\\n\\t\\t\");\n    sj.add(\"Attributes Ranks:\");\n    sj.add(\"att\\t\\tweight\");\n    sj.add(\"-------------------------\");\n    for (int i = 0; i < ranks.length; i++) {\n      sj.add(String.format(\"%02d\\t\\t%1.3f\", i + 1, ranks[i]));\n    }\n    return sj.toString();\n  }\n\n  public static String printCutOffPoint(double[] ranks, double threshold) {\n    List<Double> pasRanks = Arrays.stream(ranks).boxed().collect(Collectors.toList());\n\n    StringBuilder sb = new StringBuilder();\n    sb.append(String.format(\"Cutoff point using entropy measure : %02.3f attributes\",\n            CutOffPoint2.entropy(pasRanks)));\n    sb.append(\"\\n\");\n    sb.append(String.format(\"Cutoff point using Huffman measure : %02.3f attributes\",\n            CutOffPoint2.huffman(pasRanks)));\n    sb.append(\"\\n\");\n    sb.append(String.format(\"Cutoff point using threshold measure : %02.3f attributes\",\n            CutOffPoint2.threshold(pasRanks, threshold)));\n    return sb.toString();\n  }\n\n  /**\n   * Map each instance in data into its internal presentation values, cast double into int because\n   * the data type is \"nominal\", and \"numeric\" attributes should be \"discretized\" first\n   *\n   * @param data\n   * @return pair of\n   * key: List of int arrays represent the internal values of data items\n   * value: int array to hold the frequency of each label\n   */\n  public static Tuple2<Collection<int[]>, int[]> mapIdataAndLabels(Instances data) {\n    final int labelIndex = data.classIndex();\n    assert labelIndex == data.numAttributes() - 1;\n\n    Collection<int[]> lineData = data.stream()\n            .map(PasUtils2::toIntArray)\n            .collect(Collectors.toList());\n\n    int[] labelsCount = new int[data.attribute(data.classIndex()).numValues()];\n    lineData.stream()\n            .mapToInt(row -> row[labelIndex])\n            .forEach(index -> labelsCount[index]++);\n\n    return Tuple2.of(lineData, labelsCount);\n  }\n\n  /**\n   * Return array containing number of items in each corresponding attribute\n   *\n   * @param data\n   * @return number of distinct items in each attributes\n   */\n  public static int[] countItemsInAttributes(Instances data) {\n    int[] result = new int[data.numAttributes()];\n    for (int i = 0; i < result.length; i++) {\n      result[i] = data.attribute(i).numValues();\n    }\n    return result;\n  }\n\n  public static String formatIntPattern(int maxDigit) {\n    int digits = (int) (Math.ceil(Math.log10(maxDigit)));\n    return \"%0\" + digits + \"d\";\n  }\n\n  /**\n   * map and instance to ints internal representation in Instances class in \"int\" format rather than double\n   *\n   * @param instance\n   * @return\n   */\n  public static int[] toIntArray(Instance instance) {\n    int[] result = new int[instance.numValues()]; //assert numValues == numAttributes data is not sparse\n    for (int i = 0; i < result.length; i++) {\n      result[i] = (int) instance.value(i);\n    }\n    return result;\n  }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/weka/attributeSelection/pas2/PasUtils2.java b/src/weka/attributeSelection/pas2/PasUtils2.java
--- a/src/weka/attributeSelection/pas2/PasUtils2.java	(revision 738757a4a6578a5b57eb5e2e9256b6f1ae6ba237)
+++ b/src/weka/attributeSelection/pas2/PasUtils2.java	(date 1617372974130)
@@ -4,7 +4,6 @@
 import org.slf4j.LoggerFactory;
 import weka.core.Instance;
 import weka.core.Instances;
-
 import java.util.*;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ArtifactsWorkspaceSettings\">\n    <artifacts-to-build>\n      <artifact name=\"weka.pas_1\" />\n    </artifacts-to-build>\n  </component>\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"BranchesTreeState\">\n    <expand>\n      <path>\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n        <item name=\"LOCAL_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n      </path>\n      <path>\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n      </path>\n      <path>\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n        <item name=\"GROUP_NODE:origin\" type=\"e8cecc67:BranchNodeDescriptor\" />\n      </path>\n    </expand>\n    <select>\n      <path>\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n        <item name=\"LOCAL_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\n        <item name=\"BRANCH:master\" type=\"e8cecc67:BranchNodeDescriptor\" />\n      </path>\n    </select>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"4b4ffecf-fd2d-4ac9-8d65-3aedb6a8be09\" name=\"Default\" comment=\"Initial commit\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"CodeStyleSettingsInfer\">\n    <option name=\"done\" value=\"true\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Enum\" />\n        <option value=\"JUnit5 Test Class\" />\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"PREVIOUS_COMMIT_AUTHORS\">\n      <list>\n        <option value=\"Suhel Hammoud\" />\n      </list>\n    </option>\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitSEFilterConfiguration\">\n    <file-type-list>\n      <filtered-out-file-type name=\"LOCAL_BRANCH\" />\n      <filtered-out-file-type name=\"REMOTE_BRANCH\" />\n      <filtered-out-file-type name=\"TAG\" />\n      <filtered-out-file-type name=\"COMMIT_BY_MESSAGE\" />\n    </file-type-list>\n  </component>\n  <component name=\"ProjectCodeStyleSettingsMigration\">\n    <option name=\"version\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"1PSEWL7AzW6gpuWGM2sXyPBjsuS\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\n    <ConfirmationsSetting value=\"1\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"autoscrollFromSource\" value=\"true\" />\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"Downloaded.Files.Path.Enabled\" value=\"true\" />\n    <property name=\"GenerateAntBuildDialog.backupFiles\" value=\"true\" />\n    <property name=\"GenerateAntBuildDialog.enableUiFormCompile\" value=\"true\" />\n    <property name=\"GenerateAntBuildDialog.forceTargetJdk\" value=\"true\" />\n    <property name=\"GenerateAntBuildDialog.outputFileNameProperty\" value=\"weka.plus\" />\n    <property name=\"Repository.Attach.Annotations\" value=\"false\" />\n    <property name=\"Repository.Attach.JavaDocs\" value=\"false\" />\n    <property name=\"Repository.Attach.Sources\" value=\"false\" />\n    <property name=\"SHARE_PROJECT_CONFIGURATION_FILES\" value=\"true\" />\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n    <property name=\"add_unversioned_files\" value=\"true\" />\n    <property name=\"aspect.path.notification.shown\" value=\"true\" />\n    <property name=\"com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary\" value=\"JUnit5\" />\n    <property name=\"com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5\" value=\"\" />\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/src/weka/attributeSelection/pas2\" />\n    <property name=\"nodejs_package_manager_path\" value=\"npm\" />\n    <property name=\"project.structure.last.edited\" value=\"Project\" />\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\n    <property name=\"restartRequiresConfirmation\" value=\"false\" />\n    <property name=\"settings.editor.selected.configurable\" value=\"editor.preferences.tabs\" />\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/src/weka/attributeSelection/pas2\" />\n      <recent name=\"$PROJECT_DIR$/data/odri/conf\" />\n      <recent name=\"$PROJECT_DIR$/src/odri/experiments\" />\n      <recent name=\"$PROJECT_DIR$/src/odriTests\" />\n      <recent name=\"$PROJECT_DIR$/src/odri-tests\" />\n    </key>\n    <key name=\"CreateTestDialog.Recents.Supers\">\n      <recent name=\"\" />\n    </key>\n    <key name=\"CreateTestDialog.RecentsKey\">\n      <recent name=\"sensetivity\" />\n    </key>\n    <key name=\"CopyClassDialog.RECENTS_KEY\">\n      <recent name=\"weka.attributeSelection\" />\n      <recent name=\"odri.experiments\" />\n      <recent name=\"weka.classifiers.rules\" />\n      <recent name=\"weka.classifiers.rules.early\" />\n      <recent name=\"sensetivity\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Application.CasUtils\">\n    <configuration name=\"ATest2\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"weka.attributeSelection.pas2.ATest2\" />\n      <module name=\"weka.plus\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"weka.attributeSelection.pas2.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"AppLauncher\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"AppLauncher\" />\n      <module name=\"weka.plus\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"CasUtils\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"weka.attributeSelection.cas.CasUtils\" />\n      <module name=\"weka.plus\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"weka.attributeSelection.cas.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"Application\" factoryName=\"Application\">\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"ArquillianJUnit\" factoryName=\"\" nameIsGenerated=\"true\">\n      <option name=\"arquillianRunConfiguration\">\n        <value>\n          <option name=\"containerStateName\" value=\"\" />\n        </value>\n      </option>\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"FilesUtilsTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"weka.plus\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"sensetivity.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"sensetivity\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"sensetivity.FilesUtilsTest\" />\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"%MODULE_WORKING_DIR%\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"StoryTest.equalsOn\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"weka.plus\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"sensetivity.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"sensetivity\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"sensetivity.StoryTest\" />\n      <option name=\"METHOD_NAME\" value=\"equalsOn\" />\n      <option name=\"TEST_OBJECT\" value=\"method\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"%MODULE_WORKING_DIR%\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JUnit\" factoryName=\"JUnit\">\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"%MODULE_WORKING_DIR%\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"TestNG\">\n      <option name=\"TEST_OBJECT\" value=\"CLASS\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"%MODULE_WORKING_DIR%\" />\n      <properties />\n      <listeners />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <list>\n      <item itemvalue=\"Application.AppLauncher\" />\n      <item itemvalue=\"Application.ATest2\" />\n      <item itemvalue=\"JUnit.FilesUtilsTest\" />\n      <item itemvalue=\"JUnit.StoryTest.equalsOn\" />\n      <item itemvalue=\"Application.CasUtils\" />\n    </list>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.CasUtils\" />\n        <item itemvalue=\"Application.AppLauncher\" />\n        <item itemvalue=\"Application.ATest2\" />\n        <item itemvalue=\"JUnit.StoryTest.equalsOn\" />\n        <item itemvalue=\"JUnit.FilesUtilsTest\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"project-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"4b4ffecf-fd2d-4ac9-8d65-3aedb6a8be09\" name=\"Default\" comment=\"\" />\n      <created>1527227837904</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1527227837904</updated>\n      <workItem from=\"1612010339234\" duration=\"472000\" />\n      <workItem from=\"1612010834352\" duration=\"49000\" />\n      <workItem from=\"1612015652234\" duration=\"353000\" />\n      <workItem from=\"1612016035088\" duration=\"603000\" />\n      <workItem from=\"1612069809164\" duration=\"662000\" />\n      <workItem from=\"1612323776657\" duration=\"244000\" />\n      <workItem from=\"1612380847237\" duration=\"610000\" />\n      <workItem from=\"1614093288890\" duration=\"1093000\" />\n      <workItem from=\"1614097487088\" duration=\"599000\" />\n      <workItem from=\"1614415509893\" duration=\"6000\" />\n      <workItem from=\"1615288130263\" duration=\"740000\" />\n      <workItem from=\"1615788579267\" duration=\"36000\" />\n      <workItem from=\"1616224192991\" duration=\"80000\" />\n      <workItem from=\"1617157287817\" duration=\"4312000\" />\n      <workItem from=\"1617257346139\" duration=\"1438000\" />\n      <workItem from=\"1617259146509\" duration=\"10072000\" />\n      <workItem from=\"1617337252058\" duration=\"11562000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Initial commit\">\n      <created>1527230077442</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1527230077442</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"2\" />\n    <servers />\n  </component>\n  <component name=\"TodoView\">\n    <todo-panel id=\"selected-file\">\n      <is-autoscroll-to-source value=\"true\" />\n    </todo-panel>\n    <todo-panel id=\"all\">\n      <are-packages-shown value=\"true\" />\n      <is-autoscroll-to-source value=\"true\" />\n    </todo-panel>\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"UnknownFeatures\">\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\"*.csv\" />\n  </component>\n  <component name=\"Vcs.Log.History.Properties\">\n    <option name=\"COLUMN_ORDER\">\n      <list>\n        <option value=\"0\" />\n        <option value=\"2\" />\n        <option value=\"3\" />\n        <option value=\"1\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"1\">\n          <value>\n            <State>\n              <option name=\"SHOW_ONLY_AFFECTED_CHANGES\" value=\"true\" />\n            </State>\n          </value>\n        </entry>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"master\" />\n                      </list>\n                    </value>\n                  </entry>\n                  <entry key=\"text\">\n                    <value>\n                      <list>\n                        <option value=\"sensitivity\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"OPEN_GENERIC_TABS\">\n      <map>\n        <entry key=\"1\" value=\"TOOL_WINDOW\" />\n      </map>\n    </option>\n    <option name=\"RECENT_FILTERS\">\n      <map>\n        <entry key=\"Branch\">\n          <value>\n            <list />\n          </value>\n        </entry>\n        <entry key=\"User\">\n          <value>\n            <list />\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Initial Commit\" />\n    <MESSAGE value=\"Initial commit\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Initial commit\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <breakpoints>\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\n          <url>jar://$PROJECT_DIR$/lib/weka-src.jar!/src/main/java/weka/gui/explorer/ClassifierPanel.java</url>\n          <line>1526</line>\n          <option name=\"timeStamp\" value=\"2\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\n          <url>jar://$PROJECT_DIR$/lib/weka-src.jar!/src/main/java/weka/gui/explorer/ClassifierErrorsPlotInstances.java</url>\n          <line>446</line>\n          <option name=\"timeStamp\" value=\"3\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\n          <url>file://$PROJECT_DIR$/src/weka/attributeSelection/PasAttributeEval.java</url>\n          <line>256</line>\n          <option name=\"timeStamp\" value=\"6\" />\n        </line-breakpoint>\n      </breakpoints>\n    </breakpoint-manager>\n  </component>\n  <component name=\"antWorkspaceConfiguration\">\n    <option name=\"IS_AUTOSCROLL_TO_SOURCE\" value=\"false\" />\n    <option name=\"FILTER_TARGETS\" value=\"false\" />\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/weka_plus$AppLauncher.ic\" NAME=\"AppLauncher Coverage Results\" MODIFIED=\"1592729181260\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"idea\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 738757a4a6578a5b57eb5e2e9256b6f1ae6ba237)
+++ b/.idea/workspace.xml	(date 1617379452023)
@@ -35,6 +35,8 @@
   <component name="ChangeListManager">
     <list default="true" id="4b4ffecf-fd2d-4ac9-8d65-3aedb6a8be09" name="Default" comment="Initial commit">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/weka/attributeSelection/Pas2AttributeEval.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/weka/attributeSelection/Pas2AttributeEval.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/weka/attributeSelection/pas2/PasUtils2.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/weka/attributeSelection/pas2/PasUtils2.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -61,7 +63,7 @@
     </option>
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="master" />
+        <entry key="$PROJECT_DIR$" value="pas2" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -131,7 +133,7 @@
       <recent name="sensetivity" />
     </key>
   </component>
-  <component name="RunManager" selected="Application.CasUtils">
+  <component name="RunManager" selected="Application.AppLauncher">
     <configuration name="ATest2" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
       <option name="MAIN_CLASS_NAME" value="weka.attributeSelection.pas2.ATest2" />
       <module name="weka.plus" />
@@ -237,14 +239,14 @@
     <list>
       <item itemvalue="Application.AppLauncher" />
       <item itemvalue="Application.ATest2" />
+      <item itemvalue="Application.CasUtils" />
       <item itemvalue="JUnit.FilesUtilsTest" />
       <item itemvalue="JUnit.StoryTest.equalsOn" />
-      <item itemvalue="Application.CasUtils" />
     </list>
     <recent_temporary>
       <list>
-        <item itemvalue="Application.CasUtils" />
         <item itemvalue="Application.AppLauncher" />
+        <item itemvalue="Application.CasUtils" />
         <item itemvalue="Application.ATest2" />
         <item itemvalue="JUnit.StoryTest.equalsOn" />
         <item itemvalue="JUnit.FilesUtilsTest" />
